{{ 'first.css' | asset_url | stylesheet_tag }}

<div class="face-analysis-container">
  <div class="face-analysis-card">
    <div class="face-analysis-header">
      <h2 class="face-analysis-title">{{ block.settings.title }}</h2>
      <p class="face-analysis-description">{{ block.settings.description }}</p>
    </div>

    <div class="face-analysis-body">
      <!-- Image preview -->
      <div class="face-analysis-preview">
        <img 
          id="preview-image"
          src="{{ '265x265.png' | asset_url }}" 
          alt="Uploaded Image Preview" 
          width="256"
          height="256" 
          class="preview-image"
        />
        <div class="preview-overlay">
          <p>Image Preview</p>
        </div>
      </div>

      <!-- Added webcam section -->
      <div id="webcam-section" class="webcam-section" style="display:none;">
        <video id="webcam-video" width="256" height="256" autoplay playsinline></video>
        <canvas id="webcam-canvas" width="256" height="256" style="display:none;"></canvas>
      </div>

      <!-- Upload -->
      <div class="upload-section">
        <input id="picture" type="file" class="hidden-file" accept="image/png, image/jpeg" />
        <button type="button" class="upload-button" onclick="document.getElementById('picture').click()">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon-upload">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" x2="12" y1="3" y2="15"/>
          </svg>
          Upload Image
        </button>
        <!-- Added webcam buttons -->
        <button type="button" class="webcam-button" id="webcam-btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
            <circle cx="12" cy="13" r="4"/>
          </svg>
          Use Camera
        </button>
        <button type="button" class="capture-button" id="capture-btn" style="display:none;">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <circle cx="12" cy="12" r="3"/>
          </svg>
          Capture Photo
        </button>
        <button type="button" class="stop-camera-button" id="stop-camera-btn" style="display:none;">
          Stop Camera
        </button>
        <p class="upload-note">PNG, JPG, or JPEG up to 10MB.</p>
      </div>

      <!-- Success / Error message -->
      <p id="upload-message" class="upload-message" style="display:none; font-weight:bold; margin-top: 10px;"></p>

      <!-- Analyze -->
      <button class="analyze-button" disabled id="analyze-btn">Analyze Face</button>

      <!-- Added analysis results section -->
      <!-- Analysis Images Section -->
      <div id="analysis-images" style="display:none;">
        <div class="analysis-section">
          <!-- YOLO Detection Image -->
          <div class="analysis-card">
            <div class="analysis-header">
              <div class="analysis-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M9 12l2 2 4-4"/>
                  <path d="M21 12c.552 0 1-.448 1-1V5c0-.552-.448-1-1-1H3c-.552 0-1 .448-1 1v6c0 .552.448 1 1 1"/>
                </svg>
              </div>
              <div class="analysis-title">
                <h3>Detected Issues</h3>
                <p>Areas of concern identified on your face</p>
              </div>
            </div>
            <div class="detection-container">
              <img id="yolo-annotated-image" src="/placeholder.svg" alt="YOLO Detection Results" width="300" height="300" style="width: 100%; height: auto; border: 1px solid #e1e3e5; border-radius: 8px; display: none;" />
            </div>
          </div>

          <!-- Segmentation Image -->
          <div class="analysis-card">
            <div class="analysis-header">
              <div class="analysis-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="12" cy="12" r="3"/>
                  <path d="M12 1v6m0 6v6m11-7h-6m-6 0H1"/>
                </svg>
              </div>
              <div class="analysis-title">
                <h3>Skin Segmentation</h3>
                <p>Different skin condition areas highlighted</p>
              </div>
            </div>
            <div class="segmentation-container">
              <img id="segmentation-overlay-image" src="/placeholder.svg" alt="Segmentation Analysis" width="300" height="300" style="width: 100%; height: auto; border: 1px solid #e1e3e5; border-radius: 8px; display: none;" />
            </div>
          </div>
        </div>
      </div>

      <!-- Product Recommendations Section -->
      <div id="product-recommendations" style="display:none;">
        <div class="recommendations-header">
          <h3>Recommended Products</h3>
          <p>Based on your skin analysis results</p>
        </div>
        
        <div class="recommendations-filters">
          <span class="filter-label">Filtering by:</span>
          <div id="active-filters" class="active-filters"></div>
        </div>
        
        <div id="recommended-products" class="product-grid">
          {% paginate collections.all.products by 20 %}
            {% for product in collections.all.products %}
              <div class="product-item" 
                   data-tags="{{ product.tags | join: ',' | downcase }}"
                   data-title="{{ product.title | downcase }}"
                   style="display: none;">
                <div class="product-image">
                  <img src="{{ product.featured_image | img_url: '200x200' }}" 
                       alt="{{ product.title }}" 
                       width="200" 
                       height="200">
                </div>
                <div class="product-info">
                  <h4 class="product-title">{{ product.title }}</h4>
                  <p class="product-price">{{ product.price | money }}</p>
                  <div class="product-tags">
                    {% for tag in product.tags limit: 3 %}
                      <span class="tag">{{ tag }}</span>
                    {% endfor %}
                  </div>
                  <a href="{{ product.url }}" class="product-link">View Product</a>
                </div>
              </div>
            {% endfor %}
          {% endpaginate %}
        </div>
        
        <div id="no-products" class="no-products" style="display: none;">
          <p>No products found matching your skin analysis. Please check back later for new recommendations.</p>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const input = document.getElementById('picture');
    const preview = document.getElementById('preview-image');
    const message = document.getElementById('upload-message');
    const analyzeBtn = document.getElementById('analyze-btn');
    const analysisImages = document.getElementById('analysis-images');
    const yoloImage = document.getElementById('yolo-annotated-image');
    const segmentationImage = document.getElementById('segmentation-overlay-image');
    const productRecommendations = document.getElementById('product-recommendations');
    const activeFiltersDiv = document.getElementById('active-filters');
    const productItems = document.querySelectorAll('.product-item');
    const noProductsDiv = document.getElementById('no-products');
    
    const webcamBtn = document.getElementById('webcam-btn');
    const captureBtn = document.getElementById('capture-btn');
    const stopCameraBtn = document.getElementById('stop-camera-btn');
    const webcamSection = document.getElementById('webcam-section');
    const webcamVideo = document.getElementById('webcam-video');
    const webcamCanvas = document.getElementById('webcam-canvas');
    let webcamStream = null;
    let uploadedFile = null;

    input.addEventListener('change', function () {
      const file = this.files[0];
      if (file) {
        preview.src = URL.createObjectURL(file);
        message.style.display = 'none';
        analyzeBtn.disabled = false;
        uploadedFile = file;
        analysisImages.style.display = 'none';
        productRecommendations.style.display = 'none';
        hideWebcam();
      }
    });

    webcamBtn.addEventListener('click', function() {
      startWebcam();
    });

    captureBtn.addEventListener('click', function() {
      capturePhoto();
    });

    stopCameraBtn.addEventListener('click', function() {
      hideWebcam();
    });

    function startWebcam() {
      navigator.mediaDevices.getUserMedia({ video: true })
        .then(function(stream) {
          webcamStream = stream;
          webcamVideo.srcObject = stream;
          webcamSection.style.display = 'block';
          captureBtn.style.display = 'inline-flex';
          stopCameraBtn.style.display = 'inline-flex';
          webcamBtn.style.display = 'none';
        })
        .catch(function(err) {
          message.textContent = 'Error accessing camera: ' + err.message;
          message.style.color = 'red';
          message.style.display = 'block';
        });
    }

    function capturePhoto() {
      const context = webcamCanvas.getContext('2d');
      context.drawImage(webcamVideo, 0, 0, 256, 256);
      
      webcamCanvas.toBlob(function(blob) {
        uploadedFile = new File([blob], 'webcam-photo.jpg', { type: 'image/jpeg' });
        preview.src = URL.createObjectURL(blob);
        analyzeBtn.disabled = false;
        analysisImages.style.display = 'none';
        productRecommendations.style.display = 'none';
        hideWebcam();
      }, 'image/jpeg', 0.8);
    }

    function hideWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }
      webcamSection.style.display = 'none';
      captureBtn.style.display = 'none';
      stopCameraBtn.style.display = 'none';
      webcamBtn.style.display = 'inline-flex';
    }

    analyzeBtn.addEventListener('click', function () {
      if (!uploadedFile) {
        message.textContent = 'Please upload an image first.';
        message.style.color = 'red';
        message.style.display = 'block';
        return;
      }

      const formData = new FormData();
      formData.append('photo', uploadedFile);

      message.textContent = 'Analyzing image...';
      message.style.color = 'black';
      message.style.display = 'block';
      analyzeBtn.disabled = true;

      const apiEndpoint = '{{ block.settings.api_endpoint | default: "http://localhost:8000/upload/" }}';
      
      fetch(apiEndpoint, {
        method: 'POST',
        body: formData,
        credentials: 'include',
      })
      .then(response => {
        console.log('Response status:', response.status);
        console.log('Response headers:', response.headers);
        
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          return response.text().then(text => {
            console.error('Non-JSON response received:', text);
            throw new Error(`Server returned ${contentType || 'unknown content type'} instead of JSON. Response: ${text.substring(0, 200)}...`);
          });
        }
        
        return response.json();
      })
      .then(data => {
        analyzeBtn.disabled = false;
        if (data.error) {
          message.textContent = 'Error: ' + data.error;
          message.style.color = 'red';
        } else {
          let resultHTML = '✅ Image analyzed successfully!<br>';
          
          if (data.skin_type) {
            resultHTML += `<strong>Skin Type:</strong> ${data.skin_type}<br>`;
          }
          
          if (data.left_eye_color) {
            resultHTML += `<strong>Left Eye Color:</strong> ${data.left_eye_color}<br>`;
          }
          
          if (data.right_eye_color) {
            resultHTML += `<strong>Right Eye Color:</strong> ${data.right_eye_color}<br>`;
          }
          
          if (data.acne_pred && data.acne_confidence) {
            resultHTML += `<strong>Acne Level:</strong> ${data.acne_pred} (Confidence: ${(data.acne_confidence * 100).toFixed(1)}%)<br>`;
          }
          
          if (data.type_probs && data.type_probs.length === 3) {
            resultHTML += `<strong>Skin Type Probabilities:</strong><br>`;
            resultHTML += `• Dry: ${(data.type_probs[0] * 100).toFixed(1)}%<br>`;
            resultHTML += `• Normal: ${(data.type_probs[1] * 100).toFixed(1)}%<br>`;
            resultHTML += `• Oily: ${(data.type_probs[2] * 100).toFixed(1)}%<br>`;
          }
          
          if (data.yolo_boxes && data.yolo_boxes.length > 0) {
            resultHTML += `<strong>Detected Issues:</strong><br>`;
            
            // Group detections by type and count them
            const detectionCounts = {};
            data.yolo_boxes.forEach(box => {
              const issueType = box.label || box.class || 'Unknown';
              if (detectionCounts[issueType]) {
                detectionCounts[issueType]++;
              } else {
                detectionCounts[issueType] = 1;
              }
            });
            
            // Display each type with count and confidence
            Object.entries(detectionCounts).forEach(([issueType, count]) => {
              // Find the highest confidence for this issue type
              const maxConfidence = Math.max(...data.yolo_boxes
                .filter(box => (box.label || box.class) === issueType)
                .map(box => box.confidence || 0));
              
              resultHTML += `• ${issueType}: ${count} area${count > 1 ? 's' : ''} (${(maxConfidence * 100).toFixed(1)}% confidence)<br>`;
            });
          }
          
          message.innerHTML = resultHTML;
          message.style.color = 'green';

          if(data.cropped_face){
            preview.src = data.cropped_face;
          }

          if(data.yolo_annotated) {
            yoloImage.src = data.yolo_annotated;
            yoloImage.style.display = 'block';
          }

          if(data.segmentation_overlay) {
            segmentationImage.src = data.segmentation_overlay;
            segmentationImage.style.display = 'block';
          }

          if(data.yolo_annotated || data.segmentation_overlay) {
            analysisImages.style.display = 'block';
          }

          showProductRecommendations(data);
        }
      })
      .catch(err => {
        analyzeBtn.disabled = false;
        console.error('Full error details:', err);
        
        if (err.message.includes('Failed to fetch')) {
          message.textContent = 'Network error: Cannot connect to API server. Make sure Django is running at ' + apiEndpoint;
        } else if (err.message.includes('JSON')) {
          message.textContent = 'API Error: Server returned HTML instead of JSON. Check your Django server and endpoint URL.';
        } else {
          message.textContent = 'Upload failed: ' + err.message;
        }
        message.style.color = 'red';
      });
    });

    function showProductRecommendations(analysisData) {
      const filters = [];
      
      // Add skin type filter
      if (analysisData.skin_type) {
        filters.push(analysisData.skin_type.toLowerCase());
      }
      
      // Add detected issue filters from YOLO
      if (analysisData.yolo_boxes && analysisData.yolo_boxes.length > 0) {
        const detectedIssues = [...new Set(analysisData.yolo_boxes.map(box => 
          (box.label || box.class || '').toLowerCase()
        ))];
        filters.push(...detectedIssues);
      }
      
      if (analysisData.segmentation_results && Array.isArray(analysisData.segmentation_results)) {
        const segmentationIssues = analysisData.segmentation_results
          .map(result => {
            // Handle different possible structures of segmentation results
            if (typeof result === 'string') {
              return result.toLowerCase();
            } else if (result && typeof result === 'object') {
              // If it's an object, try to extract relevant fields
              return (result.class || result.label || result.name || '').toString().toLowerCase();
            }
            return '';
          })
          .filter(issue => issue.length > 0); // Remove empty strings
        filters.push(...segmentationIssues);
      }
      
      if (analysisData.skin_conditions && Array.isArray(analysisData.skin_conditions)) {
        const conditions = analysisData.skin_conditions
          .map(condition => {
            if (typeof condition === 'string') {
              return condition.toLowerCase();
            } else if (condition && typeof condition === 'object') {
              return (condition.class || condition.label || condition.name || '').toString().toLowerCase();
            }
            return '';
          })
          .filter(condition => condition.length > 0);
        filters.push(...conditions);
      }
      
      if (analysisData.segmentation_classes && Array.isArray(analysisData.segmentation_classes)) {
        const segClasses = analysisData.segmentation_classes
          .map(cls => {
            if (typeof cls === 'string') {
              return cls.toLowerCase();
            } else if (cls && typeof cls === 'object') {
              return (cls.class || cls.label || cls.name || '').toString().toLowerCase();
            }
            return '';
          })
          .filter(cls => cls.length > 0);
        filters.push(...segClasses);
      }
      
      // Add acne filter if detected
      if (analysisData.acne_pred && parseInt(analysisData.acne_pred) > 0) {
        filters.push('acne');
      }
      
      const uniqueFilters = [...new Set(filters)];
      
      // Display active filters
      activeFiltersDiv.innerHTML = uniqueFilters.map(filter => 
        `<span class="filter-tag">${filter}</span>`
      ).join('');
      
      // Filter and show relevant products
      let visibleCount = 0;
      productItems.forEach(item => {
        const productTags = item.dataset.tags.toLowerCase();
        const productTitle = item.dataset.title.toLowerCase();
        const isRelevant = uniqueFilters.some(filter => 
          productTags.includes(filter) || productTitle.includes(filter)
        );
        
        if (isRelevant) {
          item.style.display = 'block';
          visibleCount++;
        } else {
          item.style.display = 'none';
        }
      });
      
      // Show no products message if no matches found
      if (visibleCount === 0) {
        noProductsDiv.style.display = 'block';
      } else {
        noProductsDiv.style.display = 'none';
      }
      
      // Show the recommendations section
      productRecommendations.style.display = 'block';
    }
  });
</script>

{% schema %}
{
  "name": "Face Analysis Block",
  "target": "section",
  "settings": [
    {
      "type": "text",
      "id": "title",
      "label": "Block Title",
      "default": "Face Analysis Extension"
    },
    {
      "type": "text",
      "id": "description",
      "label": "Description",
      "default": "Upload an image to analyze facial features and expressions."
    },
    {
      "type": "text",
      "id": "api_endpoint",
      "label": "API Endpoint URL",
      "default": "http://localhost:8000/upload/",
      "info": "Full URL to your Django API endpoint (e.g., http://localhost:8000/upload/ or https://yourdomain.com/upload/)"
    }
  ]
}
{% endschema %}
